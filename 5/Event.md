# 0526 Event

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트(event)를 발생(trigger)시킨다. 예를 들어 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.

<br>

만약 애플리케이션이 특정 타입의 이벤트에 대해 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려 호출을 위임한다. 이때 이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러(event handler)**라 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다.

<br>

예를 들어 사용자가 버튼을 클릭하면 어떤 함수를 호출하고 싶다고 가정해보자. 이때 문제는 “언제 함수를 호출해야 하는가”이다. 사용자가 언제 버튼을 클릭할 지 알 수 없으므로 언제 함수를 호출해야 할지 알 수 없기 때문이다.

<br>

다행히 브라우저는 사용자의 버튼 클릭을 감지하여 클릭 이벤트를 발생시킬 수 있다. 그리고 특정 버튼 요소에서 클릭 이벤트가 발생하면 특정 함수(이벤트 핸들러)를 호출하도록 브라우저에게 위임(이벤트 핸들러 등록)할 수 있다. 즉, 함수를 언제 호출할 지 알 수 없으므로 개발자가 명시적으로 함수를 호출하는 것이 아니라 브라우저에게 함수 호출을 위임하는 것이다. 

<br>

이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용(interaction)이 가능하게 된다. 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 **이벤트 드리븐 프로그래밍(event-driven programming)**이라 한다.

<br>

이벤트 핸들러 어트리뷰트(사용하지말아야한다 html/css/js는 분리되어야된다는 주장이 있었다)

DOM은 버전이라고 안하고 레벨이라고 한다.

<br>

이벤트는 요소가 발생하고 브라우저가 감지한다

- 이벤트 핸들러 프로퍼티 (요소 노드, 노드는 객체, 프로퍼티)  추천

- HTML에 직접 이벤트 핸들러 어트리뷰트 (문자열로 실행문형식) 바닐라 JS에선 어트리뷰트 비추 (프레임워크/라이브러리)

- addEventListener

  이벤트를 브라우저가 호출하면서 이벤트 객체(종류 다음) 호출 =e

  우리가 호출하기 때문에 인수로 줄 수 없음

  e.target = 이벤트를 발생시킨 요소

  this 사용 x 화살표 함수를 쓰는 경우가 있어서 e.target사용

  어트리뷰트에서 가져오면 문자열 check string ''

  프로퍼티에서 가져오면 불리언 check Boolean true,false

<br>

이벤트 핸들러 등록하는 방법 3가지 = 이벤트 핸들러란 이벤트가 발생했을때 호출되는 함수 정도로 생각

<br>

HTML에 넣듯, 어트리뷰트 on 접두사를 사용 -> 함수 호출문 이벤트 핸들러의 함수 몸체를 의미

CBD(리액트,앵귤러등 라이브러리/프레임워크)에서는 다시 VIEW를 구성하는것에 지나지 않는다고 판단

<br>

script에 넣듯 이벤트 핸들러 프로퍼티 (타겟 필요)

```javascript
$button.onclick = function (){};
타겟      on +이벤트 타입
```

장점) 하나에 이벤트에 하나의 이벤트 핸들러만 바인딩할 수 있어서 프로퍼티 방식의 html,javascript가 꼬이는것 방지

<br>

addEventListener

Event.target.addEventListener('이벤트문자열',이벤트핸들러(on접두사x), capture 사용여부(t/f))

이벤트 핸들러 프로퍼티 + addEventListener = 서로 영향 x 동시적용 o

순서대로 '동일한 요소'에 대해서는 중복을 허용, 이벤트 핸들러가 동일하면 하나만 적용

## 이벤트 핸들러 제거

### EventTarget.prototype.removeEventListener

<br>

## 이벤트 객체

### 이벤트가 발생하면 다양한 정보를 담고 있는 이벤트 객체가 동적 생성

###  -> 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 매개 변수에 전달

###  target = 통상 this , .앞에  있는것

## 이벤트 전파

### DOM 트리상 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파. - >이벤트 전파

### 이벤트 핸들러는 타깃 단계와 버블링 단계 (2가지에서 이벤트를 캐치)

### 어트리뷰트 / 프로퍼티 방식은 타깃 단계와 버블링 단계만 캐치

### 캡처링 단계 캐치 위해서는 addEventListener 메서드 3번째 인수 true 전달

<br>

## 이벤트 위임

이벤트 위임이 없다면 모든 자식요소에 이벤트 핸들러를 등록해야 되서 성능 저하된다

### 부모에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃이 개발자가 기대한 DOM 요소가 아닐 수 도 있다

일반적으로 이벤트 객체의 타깃과 currenttarget은 동일한 DOM요소를 가리키지만 이벤트 위임의 경우는 다른 요소를 가리킬 수 있다 focus, blur는 이벤트가 버블링되지 않음

<br>

## 기본 동작의 변경

```javascript
e.preventDefault()// DOM 요소의 기본동작 중단
e.stoppropagation // 이벤트 전파 방지
```

<br>

## 이벤트 핸들러 내부의 this

이벤트 핸들러 어트리뷰트 -> 이벤트 핸들러 내부의 this는 전역객체

<br>

이벤트 핸들러 프로퍼티 & addEventListener 메서드 방식 -> 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM요소 -> 이벤트 객체의 currentTarget

<br>

화살표 함수로 정의한 이벤트 핸들러의 경우 상위 컨텍스트의 this,

화살표 함수 자체는 this 바인딩을 갖지 않는다.

<br>

클래스에서 이벤트 핸들러를 바인딩하는 경우 this 주의

<br>

## 이벤트 핸들러의 인수전달

어트리뷰트 (함수 호출문)

프로퍼티 / addEventListener -> 브라우저가 호출하니 함수 자체를 등록

## 커스텀 이벤트

이벤트 타입에 존재하지 않는 이벤트 생성 -> 버블링 & 취소 불가능 (원하면 두번째 인수 사용)

-> dispatchEvent 메서드로 디스패치(이벤트 발생 시키기)

->이벤트는 비동기적이나 디스패치 메서드는 동기적으로 동작 (2번째 인수에 detail가능)

->커스텀 이벤트 객체를 만든 경우 핸들러 등록은 addEventListener를 '사용해야함' ->

why? on~ 어티르뷰티/프로퍼티를 찾을 수 없기 때문에